<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Distributed Deep Neural Network (DNN) Training for Practitioners - Kfir Lev-Ari</title>
<meta name="description" content="I love both distributed systems and machine learning. However, when I started grad school, I wasn’t sure which one to choose. In my first semester, the ML 101 course wasn’t taught while  parallel computing 101 did, and so I decided based on availability :smile:">


  <meta name="author" content="Kfir Lev-Ari">
  
  <meta property="article:author" content="Kfir Lev-Ari">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Kfir Lev-Ari">
<meta property="og:title" content="Distributed Deep Neural Network (DNN) Training for Practitioners">
<meta property="og:url" content="https://kfirlevari.github.io/DNN-Training/">


  <meta property="og:description" content="I love both distributed systems and machine learning. However, when I started grad school, I wasn’t sure which one to choose. In my first semester, the ML 101 course wasn’t taught while  parallel computing 101 did, and so I decided based on availability :smile:">



  <meta property="og:image" content="https://kfirlevari.github.io/assets/images/DNN.jpg">





  <meta property="article:published_time" content="2022-01-11T00:00:00-08:00">





  

  


<link rel="canonical" href="https://kfirlevari.github.io/DNN-Training/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "",
      "url": "https://kfirlevari.github.io/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Kfir Lev-Ari Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">

<!-- insert favicons. use https://realfavicongenerator.net/ -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">kfirlevari.github.io</span>
        </a>
        <ul class="visible-links">
<li class="masthead__menu-item">
              <a href="/blog/">Blog</a>
            </li>
<li class="masthead__menu-item">
              <a href="/projects/">Projects</a>
            </li>
<li class="masthead__menu-item">
              <a href="/publications/">Publications</a>
            </li>
<li class="masthead__menu-item">
              <a href="/past-teaching/">Past Teaching</a>
            </li>
<li class="masthead__menu-item">
              <a href="/personal/">Personal</a>
            </li>
</ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      
  







<div class="page__hero--overlay" style=" background-image: linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)), url('/assets/images/DNN.jpg');">
  
    <div class="wrapper">
      <h1 id="page-title" class="page__title" itemprop="headline">
        
          Distributed Deep Neural Network (DNN) Training for Practitioners

        
      </h1>
      
        <p class="page__lead">
</p>
      
      

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          29 minute read
        
      </span>
    
  </p>


      
      
    </div>
  
  
    <span class="page__hero-caption"><a href="/personal/#photography">See more photos here</a>
</span>
  
</div>





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person" class="h-card">

  
    <div class="author__avatar">
      <img src="/assets/images/bio-photo.jpeg" alt="Kfir Lev-Ari" itemprop="image" class="u-photo">
    </div>
  

  <div class="author__content">
    <h3 class="author__name p-name" itemprop="name">
      Kfir Lev-Ari
    </h3>
    
      <div class="author__bio p-note" itemprop="description">
        <p>Senior Software Engineer at <br> Apple Cloud Services ML team</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name" class="p-locality">Sunnyvale, CA</span>
        </li>
      

      

      

      
        <li>
          <a href="mailto:kfirlevari@gmail.com" rel="me" class="u-email">
            <meta itemprop="email" content="kfirlevari@gmail.com">
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span>
          </a>
        </li>
      

      

      

      

      
        <li>
          <a href="https://www.linkedin.com/in/kfirlevari" itemprop="sameAs" rel="nofollow noopener noreferrer me">
            <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span class="label">LinkedIn</span>
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://github.com/kfirlevari" itemprop="sameAs" rel="nofollow noopener noreferrer me">
            <i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span>
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

        
      
        <li>
          <a href="https://www.strava.com/athletes/42969031" itemprop="sameAs" rel="nofollow noopener noreferrer me">
            <i class="fab fa-fw fa-strava" aria-hidden="true"></i><span class="label">Strava</span>
          </a>
        </li>
        
        
      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer me">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Distributed Deep Neural Network (DNN) Training for Practitioners">
    <meta itemprop="description" content="I love both distributed systems and machine learning. However, when I started grad school, I wasn’t sure which one to choose. In my first semester, the ML 101 course wasn’t taught while  parallel computing 101 did, and so I decided based on availability :smile:">
    <meta itemprop="datePublished" content="2022-01-11T00:00:00-08:00">
    

    <div class="page__inner-wrap">
      

      <section class="page__content e-content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title">
<i class="fas fa-project-diagram"></i> Distributed DNN Training</h4></header>
              <ul class="toc__menu">
<li><a href="#introduction">Introduction</a></li>
<li>
<a href="#dimensions-of-concurrency">Dimensions of Concurrency</a><ul>
<li><a href="#single-dnn-operator-computation">Single DNN Operator Computation</a></li>
<li>
<a href="#dnn-model-computation">DNN Model Computation</a><ul>
<li><a href="#data-parallelism">Data Parallelism</a></li>
<li><a href="#model-parallelism">Model Parallelism</a></li>
<li><a href="#layer-pipelining">Layer Pipelining</a></li>
</ul>
</li>
<li>
<a href="#handling-multiple-copies-of-a-model">Handling Multiple Copies of a Model</a><ul>
<li><a href="#model-consistency">Model Consistency</a></li>
<li><a href="#centralization">Centralization</a></li>
<li><a href="#parameter-and-gradient-compression">Parameter and Gradient Compression</a></li>
<li><a href="#optimization-algorithms">Optimization Algorithms</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#network-level-optimizations">Network Level Optimizations</a><ul>
<li>
<a href="#communication-rounds">Communication Rounds</a><ul>
<li><a href="#batch-size">Batch Size</a></li>
<li><a href="#periodic-communication">Periodic Communication</a></li>
</ul>
</li>
<li><a href="#gradient-compression">Gradient Compression</a></li>
<li><a href="#overlap">Overlap</a></li>
<li><a href="#logical-architecture">Logical Architecture</a></li>
<li><a href="#messaging-library">Messaging Library</a></li>
<li><a href="#protocols">Protocols</a></li>
</ul>
</li>
<li>
<a href="#hardware-level-optimizations">Hardware Level Optimizations</a><ul>
<li><a href="#gpu-vs-cpu">GPU vs CPU</a></li>
<li><a href="#multi-gpu-execution">Multi-GPU Execution</a></li>
<li><a href="#switch-optimizations">Switch Optimizations</a></li>
<li>
<a href="#cnn-optimizations">CNN Optimizations</a><ul>
<li><a href="#layers-fusion">Layers Fusion</a></li>
<li><a href="#flexible-buffering">Flexible Buffering</a></li>
</ul>
</li>
<li><a href="#other-optimizations">Other Optimizations</a></li>
</ul>
</li>
<li><a href="#fault-tolerance">Fault Tolerance</a></li>
<li>
<a href="#from-ideas-to-practice">From Ideas to Practice</a><ul>
<li><a href="#tensorflow--w-keras">TensorFlow ( w/ Keras)</a></li>
<li><a href="#pytorch">PyTorch</a></li>
</ul>
</li>
<li><a href="#building-a-training-service---related-topics">Building a Training Service - Related Topics</a></li>
<li><a href="#epilogue">Epilogue</a></li>
<li><a href="#refrences">Refrences</a></li>
</ul>

            </nav>
          </aside>
        
        <p>I love both distributed systems and machine learning. However, when I started grad school, I wasn’t sure which one to choose. In my first semester, the ML 101 course wasn’t taught while  parallel computing 101 did, and so I decided based on availability <img class="emoji" title=":smile:" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" height="20" width="20"></p>

<p>This topic of distributed training fascinates me because it combines essential aspects of both domains.</p>

<h2 id="introduction">Introduction</h2>

<p>In this survey, we cover strategies and techniques related to distributed DNN training.
The goal is to explore/highlight aspects of state-of-the-art approaches and make them more accessible to practitioners.</p>

<p>Some basic knowledge in deep neural networks is required (if you’re missing it, you can see Section 2 and Section 4 in <a class="citation" href="#DBLP:journals/csur/Ben-NunH19">[1]</a>, and/or Section 2 in <a class="citation" href="#DBLP:journals/csur/MayerJ20">[2]</a>).</p>

<p>The structure of this survey is as follows -</p>

<ol>
  <li>Section <a href="#dimensions-of-concurrency">Dimensions of Concurrency</a> gives an overview of the different dimensions of the parallel &amp; distributed training problem.</li>
  <li>Section <a href="#network-level-optimizations">Network Level Optimizations</a> focuses on the network aspect of training and related optimizations.</li>
  <li>Section <a href="#hardware-level-optimizations">Hardware Level Optimizations</a> discusses CPU, GPU, and switch optimizations.</li>
  <li>Section <a href="#fault-tolerance">Fault Tolerance</a> touches on a few techniques used by distributed training systems to deal with failures.</li>
  <li>Section <a href="#from-ideas-to-practice">From Ideas to Practice</a> maps the ideas presented in this survey to available tools.</li>
  <li>Section <a href="#building-a-training-service---related-topics">Building a Training Service - Related Topics</a> notes more directions to consider when building a training service</li>
</ol>

<h2 id="dimensions-of-concurrency">Dimensions of Concurrency</h2>

<p>In this section, we give a short overview of the three primary computation levels found in DNN training that can be improved with concurrency - we start with the basic unit of a single DNN operator (Section <a href="#single-dnn-operator-computation">Single DNN Operator Computation</a>), then look at a bigger picture that consists of the DNN structure itself (Section <a href="#dnn-model-computation">DNN Model Computation</a>), and finish with the highest level which is the overall training flow (Section <a href="#handling-multiple-copies-of-a-model">Handling Multiple Copies of a Model</a>).</p>

<figure class="" id="Figure1">
  <img src="/assets/images/DNN-Training-Images/Figure1.png" alt=""><figcaption>
      Figure 1. Dimensions of Concurrency in DNN Training. On the left - single operator computation, in the middle - single model evaluation (via forward evaluation &amp; back propagation), and on the right - maintaining multiple states of the same model.
Figure adapted from <a class="citation" href="#DBLP:journals/csur/Ben-NunH19">[1]</a>.</figcaption></figure>

<h3 id="single-dnn-operator-computation">Single DNN Operator Computation</h3>

<p>The main DNN operator types are - 1. Activation, 2. Fully Connected, 3. Convolution, 4. Pooling, and 5. Batch Normalization. 
Generally, the opportunities for parallelization in their computation are rooted in the locality of the operations that are done as part of each operator and the dimensionality of the data. The data dimensions are - 1. the minibatch size, 2. the number of channels/features/neurons, 3. the single sample dimensions (i.e., height, width), and 4. the convolution kernel dimensions (in convolution operator).</p>

<p>At their core, nearly all operators are computed via matrix multiplication, and many optimizations in the literature focus on that. For more info, see Section 5 in <a class="citation" href="#DBLP:journals/csur/Ben-NunH19">[1]</a>.</p>

<h3 id="dnn-model-computation">DNN Model Computation</h3>

<p>DNN models are created using SGD (see <a href="#alg1">Alg. 1.</a>). This calculation can be partitioned among multiple processors due to the following dimensions: 1. the minibatch granularity, 2. the breath of the layers, and 3. the depth of the DNN.</p>

<figure class="" id="alg1">
  <img src="/assets/images/DNN-Training-Images/Alg1.png" alt=""><figcaption>
      Alg. 1. Minibatch Stochastic Gradient Descent (SGD) with Backpropagation.
Algorithm adapted from <a class="citation" href="#DBLP:journals/csur/Ben-NunH19">[1]</a>.</figcaption></figure>

<p>There are three prominent schemes for partitioning as depicted in <a href="#Figure2">Figure 2.</a>: 1. partition by input samples (data parallelism), 2. by network structure (model parallelism), and 3. by layer (pipelining). In addition, there’s a hybrid approach that combines multiple schemes to overcome the drawbacks of each method.</p>

<figure class="" id="Figure2">
  <img src="/assets/images/DNN-Training-Images/Figure2.png" alt=""><figcaption>
      Figure 2. DNN Parallelism Schemes.
Figure adapted from <a class="citation" href="#DBLP:journals/csur/Ben-NunH19">[1]</a>.</figcaption></figure>

<h4 id="data-parallelism">Data Parallelism</h4>

<p>In this approach, minibatches are partitioned among multiple computational resources. 
Pros:</p>

<ul>
  <li>Simple to reason about.</li>
  <li>All operators except Batch Normalization operate on a single sample. Therefore in this approach, we can run forward evaluation and backpropagation almost independently.</li>
</ul>

<p>Cons:</p>

<ul>
  <li>This approach requires each resource to maintain the whole model, as each sample might modify any of the model’s parameters.</li>
</ul>

<p>For more info, see Section 6.1 in <a class="citation" href="#DBLP:journals/csur/Ben-NunH19">[1]</a>, and Section 3.2.1 in <a class="citation" href="#DBLP:journals/csur/MayerJ20">[2]</a>.</p>

<h4 id="model-parallelism">Model Parallelism</h4>

<p>In this approach, different parts of the DNN are computed on different computational resources. 
Pros:</p>

<ul>
  <li>Requires less memory from each computation resource (no need to store the whole model locally)</li>
</ul>

<p>Cons:</p>

<ul>
  <li>The minibatches are copied to all computation resources.</li>
  <li>Communication intensive (e.g., handling a fully connected layer) significantly affects performance.</li>
</ul>

<p>Generally, effectively splitting models isn’t easy, and stalling due to communication overhead or synchronizations may occur. This means that increasing the degree of model parallelism doesn’t necessarily lead to training speedup (as in <a class="citation" href="#DBLP:conf/icml/MirhoseiniPLSLZ17">[3]</a>).</p>

<p>For more info, see Section 6.2 in <a class="citation" href="#DBLP:journals/csur/Ben-NunH19">[1]</a>, and Section 3.2.2 in <a class="citation" href="#DBLP:journals/csur/MayerJ20">[2]</a>.</p>

<h4 id="layer-pipelining">Layer Pipelining</h4>

<p>Pipelining can refer to :</p>

<ol>
  <li>Overlapping computations of layers - overlapping the steps of forward evaluation, backpropagation, and weight updates.
    <ul>
      <li>Pros: mitigates processor idle time.</li>
    </ul>
  </li>
  <li>Layer partitioning - partitioning the DNN according to its depth to different computational resources
    <ul>
      <li>Pros: 1. no need to store the whole model locally, 2. fixed number of communication points between processors.</li>
    </ul>
  </li>
</ol>

<p>Cons of pipelining -</p>
<ol>
  <li>Sample arrival rate affects system utilization, and 2. latency proportional to the number of processors.</li>
</ol>

<p>For more info, see Section 6.3 in <a class="citation" href="#DBLP:journals/csur/Ben-NunH19">[1]</a>, and Section 3.2.3 in <a class="citation" href="#DBLP:journals/csur/MayerJ20">[2]</a>.</p>

<h3 id="handling-multiple-copies-of-a-model">Handling Multiple Copies of a Model</h3>

<p>In a distributed environment, there are multiple instances of SGD running independently, and therefore there are multiple copies of the model. The different distributed training algorithms can be categories by the way they address the following domains: 1. <a href="#model-consistency">Model Consistency</a>, 2. <a href="#centralization">Centralization</a>, 3.<a href="#parameter-and-gradient-compression">Parameter and Gradient Compression</a>, 4. <a href="#optimization-algorithms">Optimization Algorithms</a>.</p>

<h4 id="model-consistency">Model Consistency</h4>

<p>Consistency is essentially a tradeoff between the potential loss in model quality or convergence speed (when training instances use a stale model) and the synchronization costs (of updating instances model).</p>

<p>If we think about consistency as an axis, then that axis describes the possible states of the model as observed by the different SGD instances before running the SGD method. We have consistent model algorithms in which everyone observes the most updated model on one end. On the other end, we have inconsistent model algorithms, in which there is no guarantee on the staleness of the model that each participant holds. In between, some algorithms bound the staleness as a compromise between consistency and inconsistency.</p>

<p>Consistent model algorithms - Pros: simple to reason about. Cons: costly synchronization that hurts scaling.</p>

<p>Inconsistent model algorithms - Pros: no extra synchronization is needed. Participants train almost independently. 
Cons: it doesn’t converge in all cases.</p>

<p>Compromise approach - Pros: 1. pay for synchronization only after a bound is reached; 2. keeping lagging participants in check, and allows to add/remove on-the-fly participants;</p>

<p>It seems like the consistent model algorithms are used nowadays for up to 35-50 participants, after which the added cost of communication breaks the linear scalability. Then, for higher participant numbers, the non-consistent model algorithms are used.</p>

<p>There’s another dimension of model consolidation for inconsistent model algorithms that determines how the algorithm combines the resulting models of the different SGC instances - either post-training or several times during training.
A common post-training technique is ensemble learning (i.e., keeping an ensemble of models); other techniques are knowledge distillation (keeping an ensemble of smaller models that are trained based on a bigger one) and model averaging (that can also be used during training).</p>

<figure class="" id="Figure3">
  <img src="/assets/images/DNN-Training-Images/Figure3.png" alt=""><figcaption>
      Figure 3. Model consistency levels.
Figure adapted from <a class="citation" href="#DBLP:journals/csur/Ben-NunH19">[1]</a>.</figcaption></figure>

<p>For more info, see Section 7.1 and Section 7.4 in <a class="citation" href="#DBLP:journals/csur/Ben-NunH19">[1]</a>.</p>

<h4 id="centralization">Centralization</h4>

<p>Centralization range between the extreme of a single participant that is responsible for the collection, update, and distribution of the model (denoted by parameter server PS) to the other extreme of a completely decentralized network at which all participants share the responsibility for the model equally (in this case, the participants would rely on allreduce operations to communicate model updates among themselves).</p>

<p>The selected design choice should consider the network characteristics (topology, bandwidth, and latency) and the required level of fault tolerance.
Note that PS consists of a single node on the extreme, but it’s possible to have an ensemble of participants that act together as a PS.</p>

<p>The tradeoff between using either distribution scheme can be modeled by the communication cost per global update.</p>

<p><em>Centralize scheme</em> -</p>

<p>Pros:</p>

<ol>
  <li>PS can keep track of a “global view” of training</li>
  <li>Averaging the gradients at one location</li>
  <li>Enabling asynchronous operation mode of the training participants</li>
  <li>Participants can communicate less information by performing some of the computations on the PS</li>
  <li>Increases fault tolerance by dynamic spin-up and removal of nodes during training</li>
  <li>enable handling heterogeneity, both in training agents and in network settings (e.g., latency, x-dc)</li>
</ol>

<p>Cons:</p>

<ol>
  <li>Requires each training participant to send and receive information from a specific subset of nodes (PS nodes) - unbalanced network usage pattern, e.g., a bottleneck on the PS with the increase of participants (in some cases, can be resolved using model parallelism and pipelining on the PS side).</li>
</ol>

<p>For the PS approach to scale, there’s a need to optimize software and hardware configurations and awareness of underlying physical network topology.</p>

<ul>
  <li>
    <p>One example to such optimization (at rack scale) is  <a class="citation" href="#DBLP:conf/cloud/LuoNCPK18">[4]</a> - they show:</p>

    <ol>
      <li>Analysis of three bottlenecks due to (1) network bandwidth, (2) software framework inefficiencies, and (3) suboptimal deployment.</li>
      <li>Design &amp; evaluate a rack-scale PS that mitigates the above issues</li>
      <li>Design of an HW component that their PS is using and is responsible for rack-level and cross-rack gradient reductions</li>
    </ol>
  </li>
  <li>
    <p>Another example, is a PS algorithm that uses Stale-Sync SGD (as described in Section <a href="#model-consistency">Model Consistency</a>) - this paper <a class="citation" href="#DBLP:conf/nips/HoCCLKGGGX13">[5]</a> shows an example of such an implementation, evaluation, and proof of convergence.</p>
  </li>
</ul>

<p><em>Decentralize scheme</em> -</p>

<p>Pros: load balancing can be achieved using asynchronous training</p>

<p>Cons: doesn’t scale well (e.g., see <a class="citation" href="#DBLP:journals/corr/abs-1902-06855">[6]</a> for scalability analysis + suggested optimizations to mitigate the issues).</p>

<p>Examples of optimizations for improving the scalability of this approach:</p>

<ul>
  <li>A ring-based Allreduce that was proven to be optimal in terms of bandwidth (see proof here <a class="citation" href="#DBLP:journals/jpdc/PatarasukY09">[7]</a>).</li>
  <li>A decentralized version that is hierarchical (see Hierarchical All-reduce in <a class="citation" href="#DBLP:journals/corr/abs-1807-11205">[8]</a>).</li>
  <li>An adaptive algorithm that changes the number of partitions to correspond to the number of participants so that the network bandwidth remains constant (see  <a class="citation" href="#DBLP:conf/apsys/WangZGZ14">[9]</a>).</li>
  <li>Tunable partitioning of gradient updates that enable constant network bandwidth usage (i.e., the bandwidth remains unaffected by the number of participants). For more info, see  <a class="citation" href="#DBLP:conf/cloud/WatcharapichatM16">[10]</a>.</li>
  <li>Note that in low bandwidth or high latency networks, it might be that the decentralized approach behaves better than PS since it’s able to avoid the communication traffic jam (e.g., see two key observations on page 8 of <a class="citation" href="#DBLP:conf/nips/LianZZHZL17">[11]</a>)</li>
</ul>

<p>For more info on centralization, see Section 7.2 in <a class="citation" href="#DBLP:journals/csur/Ben-NunH19">[1]</a>, and Section 4 in <a class="citation" href="#DBLP:journals/jpdc/OuyangDXX21">[12]</a></p>

<h4 id="parameter-and-gradient-compression">Parameter and Gradient Compression</h4>

<p>Compression relates to techniques that reduce message size. Generally, there are two compression levels -</p>
<ol>
  <li>Compressing the model parameters/gradients with efficient data representations - as done via quantization (mapping continuous information into buckets that represent sets of values)</li>
  <li>Avoid sending unnecessary information altogether (e.g., sending only relevant parts of sparse gradients), which results in communication of sparse data structures.</li>
</ol>

<p>Note that some techniques are harder to implement in a decentralized scheme or even unique to the PS scheme (e.g., decreasing message size by sending activations and errors instead of parameters, relying on the PS computation capabilities to fill the missing computation steps).</p>

<p>In addition, the computational cost of compression is non-negligible, and in some cases, outweighs the communication-reduction benefits (see <a class="citation" href="#10754/662495">[13]</a>)</p>

<p>For more info, see Section 7.3 in <a class="citation" href="#DBLP:journals/csur/Ben-NunH19">[1]</a>, and 3.2 in <a class="citation" href="#DBLP:journals/jpdc/OuyangDXX21">[12]</a>.</p>

<h4 id="optimization-algorithms">Optimization Algorithms</h4>

<p>Multiple optimizations aim to improve the training process but do not necessarily relate to the distributed nature of the computation (still, we highlight that distributed training algorithms might leverage these optimizations).</p>

<p>E.g., for improving the parameter search, an algorithm might use a technique that reduces the variance of SGD (variance caused by the random sampling).</p>

<p>Another example is an algorithm that tunes its hyper-parameters during execution or an algorithm that modifies its architecture (e.g., change the structure of layers).</p>

<p>For more info, see Section 7.5 in <a class="citation" href="#DBLP:journals/csur/Ben-NunH19">[1]</a>.</p>

<h2 id="network-level-optimizations">Network Level Optimizations</h2>

<p>Given the cluster size and compute capabilities growth, communication overheads became the main bottleneck of distributed training.</p>

<p>The goal of this section is to focus on strategies for reducing it. 
In <a href="#Figure4">Figure 4.</a>, we see the different optimization levels and domains that we cover in the following subsections (each in a separate sub-section).</p>

<figure class="" id="Figure4">
  <img src="/assets/images/DNN-Training-Images/Figure4.png" alt=""><figcaption>
      Figure 4. Summary of communication optimization levels. The top level refers to communication reduction and scheduling, and the lower level to network traffic.
Figure adapted from <a class="citation" href="#DBLP:journals/jpdc/OuyangDXX21">[12]</a>.</figcaption></figure>

<h3 id="communication-rounds">Communication Rounds</h3>

<p>Training via minibatch SGD consists of multiple epochs (<em>epoch</em> is an entire pass over the dataset) and iterations (iteration is one SGD round w/ one minibatch, see <a href="#alg1">Alg. 1.</a>). In distributed training algorithms, data is often exchanged at the end of an iteration (e.g., sending gradients, sending model parameters, etc…). Therefore reducing the number of iterations means cutting down the communication rounds.</p>

<p>The two straightforward ways to reduce the total number of iterations - 1. increasing the batch size and 2. reducing the frequency of exchanging gradients and/or parameters.</p>

<h4 id="batch-size">Batch Size</h4>

<p>The batch size is a hyper-parameter that controls the amount of data read before each iteration.</p>

<p>Selecting a too small mini-batch size (see Section A in <a href="#Figure5">Figure 5.</a>) can result in both:</p>
<ol>
  <li>reduced utilization of the hardware during training (as the max concurrency level isn’t reached), as seen by the Performance line; and</li>
  <li>statistical inaccuracy due to the variances introduced into the gradients (i.e., the randomly selected samples might not represent the dataset accurately) as seen by the Validation Error line.</li>
</ol>

<p>While selecting a large batch size directly answers the concurrency aspect (see Performance line, Section C in <a href="#Figure5">Figure 5.</a>), it might hurt the model accuracy (see Validation Error line) by hurting the optimizations used during training. This can be addressed by several techniques, such as adjusting the learning rate to be a function of the minibatch size, and more (see <a class="citation" href="#DBLP:journals/corr/GoyalDGNWKTJH17">[14]</a>, and Section 3 in <a class="citation" href="#DBLP:journals/csur/Ben-NunH19">[1]</a>). Note that an earlier paper <a class="citation" href="#DBLP:conf/iclr/KeskarMNST17">[15]</a> claimed that the reason for reduced model accuracy with big minibatch sizes is a convergence to a sharp minimum vs. flat minimum with smaller sizes.</p>

<figure class="" id="Figure5">
  <img src="/assets/images/DNN-Training-Images/Figure5.png" alt=""><figcaption>
      Figure 5. Performance and accuracy of minibatch SGD after a fixed number of epochs.
Figure adapted from <a class="citation" href="#DBLP:journals/csur/Ben-NunH19">[1]</a>.</figcaption></figure>

<h4 id="periodic-communication">Periodic Communication</h4>

<p>As we mentioned before, our goal is to reduce the number of communication rounds, i.e., occurrences at which participants send/receive model parameters and/or gradients.</p>

<p>The idea here is that instead of sending the parameters and gradients after each iteration (see (a) in <a href="#Figure6">Figure 6.</a>), the average of multiple iterations will be sent after those iterations (e.g., (b) in <a href="#Figure6">Figure 6.</a>). The extreme case is a one-shot training at which nothing is sent until all iterations are done (i.e., (c) in  <a href="#Figure6">Figure 6.</a>).</p>

<p>The tradeoff of averaging is between communication (that we reduce) and accuracy (that we lose), yet studies showed multiple approaches for averaging that can reduce communication costs while keeping the desired accuracy levels (see Section 3.1.2 in <a class="citation" href="#DBLP:journals/jpdc/OuyangDXX21">[12]</a>).</p>

<figure class="" id="Figure6">
  <img src="/assets/images/DNN-Training-Images/Figure6.png" alt=""><figcaption>
      Figure 6. Different model averaging approached (from no averaging in (a) to the maximum averaging in (c)). A green block indicates computation and a yellow block corresponds to communication.
Figure adapted from <a class="citation" href="#DBLP:journals/jpdc/OuyangDXX21">[12]</a>.</figcaption></figure>

<p>Another aspect of communication rounds is their typical bursty behavior - in some algorithms (e.g., synchronous approaches), participants send their updates around the same time, leading to unbalanced network usage (in time and locations). In addition, message prioritization can help in some cases in order to meet bandwidth limitations, e.g., depend on the model state (see <a class="citation" href="#DBLP:conf/mlsys/HashemiJC19">[16]</a> and <a class="citation" href="#DBLP:conf/cloud/WeiDQHCGGGX15">[17]</a>). Note that these algorithms aren’t implemented yet in open source DL frameworks.</p>

<h3 id="gradient-compression">Gradient Compression</h3>

<p>See Section <a href="#parameter-and-gradient-compression">Parameter and Gradient Compression</a>.</p>

<h3 id="overlap">Overlap</h3>

<p>The idea here is to hide the communication overhead by performing the transmission during computation.</p>

<p>One example is performing transmission of a layer during the computations of its preceding layer. In case of high latency, there are optimizations such as sending merged gradient messages (of different layers) that can reduce the amount of data sent. In addition,</p>

<figure class="" id=" Figure7">
  <img src="/assets/images/DNN-Training-Images/Figure7.png" alt=""><figcaption>
      Figure 7. One possible case of hiding the communication time overhead behind the backpropagation. In this case, each layer gradients are transmitted as soon as they are ready.
Figure adapted from <a class="citation" href="#DBLP:journals/jpdc/OuyangDXX21">[12]</a>.</figcaption></figure>

<p>Another example is performing transmission of the weights while the current iteration is still running (while balancing training speed and accuracy). For more details on this approach of hybrid SSGD and ASGD, see <a class="citation" href="#DBLP:journals/taco/XuDZXL20">[18]</a>.</p>

<h3 id="logical-architecture">Logical Architecture</h3>

<p>For discussion about topology, see <a href="#centralization">Centralization</a>.</p>

<h3 id="messaging-library">Messaging Library</h3>

<p>According to <a class="citation" href="#DBLP:journals/jpdc/OuyangDXX21">[12]</a>, most of the parameter servers are using either gRPC or ZeroMQ (see here for a nice comparison  <a class="citation" href="#grpc-and-zeromq-comparison">[19]</a>).</p>

<p>Many message-level libraries are implementing Allreduce algorithms efficiently, such as MPI, Gloo, Baidu Allreduce, Aluminum, and BlueConnect (the latter seems to be more efficient than Gloo and Baidu Allreduce).</p>

<p>For more info, see Section 4.2 in <a class="citation" href="#DBLP:journals/jpdc/OuyangDXX21">[12]</a>.</p>

<h3 id="protocols">Protocols</h3>

<p>At this level, improving the communication can be done by reducing the cost of copying data among machines, by moving away from the expensive TCP/IP protocol over sockets (Figure (a) in <a href="#Figure8">Figure 8.</a>, to IPoIB (internet over InfiniBand) or RDMA (Figures (b) and (c) in <a href="#Figure8">Figure 8.</a>)</p>

<p>RDMA allows one machine to read/write directly from/to the memory of another device without going through the OS (middle layer in the figures). This enables high performance and low latency networking. Further optimizations exist, such as letting GPUs communicate directly over RDMA or doing an adaptive RDMA by dynamically adjusting gRPC message sizes.</p>

<figure class="" id="Figure8">
  <img src="/assets/images/DNN-Training-Images/Figure8.png" alt=""><figcaption>
      Figure 8. Comparison of TCP/IP Socket, IPoIB, and RDMA.
Figure adapted from <a class="citation" href="#DBLP:journals/jpdc/OuyangDXX21">[12]</a>.</figcaption></figure>

<p>Experiments show that using RDMA or IPoIB can significantly speed up training. Some even show near-linear speedup with RDMA when scaling training on 100 GPUs.</p>

<p>For more info, See Section 4 in <a class="citation" href="#DBLP:journals/jpdc/OuyangDXX21">[12]</a>.</p>

<h2 id="hardware-level-optimizations">Hardware Level Optimizations</h2>

<h3 id="gpu-vs-cpu">GPU vs CPU</h3>

<p>The performance benefits of GPU compared to CPU depend on many factors, such as whether the job is processing-bound or memory-bound, the efficiency of the implementation, and the hardware characteristics.</p>

<ul>
  <li>
    <p>In <a class="citation" href="#DBLP:conf/isca/LeeKCDKNSSCHSD10">[20]</a> Intel show how the actual gap between GPU and CPU can be only 2.5x in favor of GPU when using the proper optimizations and HW characteristics. In that paper, they cover the following items:</p>

    <ol>
      <li>CPU optimizations - multithreading, cache blocking, and reorganization of memory accesses for SIMD-ification.</li>
      <li>GPU optimizations - minimizing global synchronization and using local shared buffers.</li>
      <li>HW architecture guidelines - high compute flops and memory bandwidth, large caches, gather/scatter support, efficient synchronization and cache coherence, and fixed functional units.</li>
    </ol>
  </li>
  <li>
    <p>Some systems use CPUs and GPUs for training, and solely CPUs for inference - since GPUs are great for bandwidth but not for latency (see <a class="citation" href="#DBLP:conf/hpca/HazelwoodBBCDDF18">[21]</a>, and <a class="citation" href="#DBLP:journals/pvldb/ZouJLGWX14">[22]</a>). 
  Other relies solely on CPUs for training due to the abundance of available resources (see  <a class="citation" href="#DBLP:conf/nips/DeanCMCDLMRSTYN12">[23]</a>, and <a class="citation" href="#DBLP:conf/osdi/ChilimbiSAK14">[24]</a>)</p>
    <ul>
      <li>There are some interesting optimizations in these papers, e.g., in <a class="citation" href="#DBLP:conf/osdi/ChilimbiSAK14">[24]</a> they partition the DL model layers to fit L3 cache, which shows to improve performance.</li>
    </ul>
  </li>
</ul>

<h3 id="multi-gpu-execution">Multi-GPU Execution</h3>

<p>Gaining performance from multi-GPU scaling isn’t trivial, and understanding the performance impact of GPUs interconnections is essential.</p>

<p>In <a class="citation" href="#DBLP:journals/tpds/LiSCLLTB20">[25]</a> they perform an evaluation of latest GPU interconnections w.r.t. raw startup latency, sustainable uni/bi-directional bandwidth, network topology, communication efficiency, routing, and NUMA (non uniform memory access) effects, under two communication patterns - Peer-to-Peer, and Collective.</p>

<p>They identified several items, e.g., an “anti-locality” pattern (in some NUMA scenarios) at which nearby memory access presents lower performance than remote memory access, and suggested that the root cause is in the unbalanced physical signal paths (e.g., in PCIe-switch chipsets they used).</p>

<h3 id="switch-optimizations">Switch Optimizations</h3>

<p>In <a class="citation" href="#DBLP:conf/nsdi/SapioC0NKKKMPR21">[26]</a> they show how to ease network bottleneck by performing the aggregation part of training on programmable switches (they focus on a single-rack).</p>

<p>Although these aggregations can be done on the PS side (when using the PS approach), there’s a cost of required computation resources and network bandwidth.</p>

<h3 id="cnn-optimizations">CNN Optimizations</h3>

<h4 id="layers-fusion">Layers Fusion</h4>

<p>Layer fusion is a technique for accelerating CNN by <em>fusing</em> the processing of multiple CNN layers. 
Generally, instead of waiting for each layer processing to complete (which results in off-chip memory consumption for the large intermediate states between layers), the input-data processing order is altered to leverage caching of intermediate states of adjacents layers (see  <a class="citation" href="#DBLP:conf/micro/AlwaniCFM16">[27]</a>).</p>

<h4 id="flexible-buffering">Flexible Buffering</h4>

<p>The same set of weights is used in all image evaluations in CNN networks.</p>

<p>Accelerators leverage this by fetching batches of images at a time into on-chip memory, bringing blocks of weights to the on-chip memory, and then reusing the same weight block over the batched images for layer evaluation.</p>

<p>If we consider a given on-chip storage budget, we see a tradeoff between the batch size (i.e., the number of images) and the amount of data per image stored on-chip.</p>

<p>This means that by increasing the batch size, we reduce the number of times we need to fetch weight blocks into memory (i.e., reducing the weights bandwidth) but pay by increasing the required bandwidth for transferring data (as we store less per image on-chip).</p>

<p>In  <a class="citation" href="#DBLP:conf/fccm/ShenFM17">[28]</a> they propose a flexible accelerator design that sets the batch size after considering optimal memory bandwidth.</p>

<h3 id="other-optimizations">Other Optimizations</h3>

<p>For a discussion about other type of hardware approaches (e.g., FPGAs, TPUs) see Section 3.1.1 in <a class="citation" href="#DBLP:journals/csur/MayerJ20">[2]</a>.</p>

<h2 id="fault-tolerance">Fault Tolerance</h2>

<p>What does it mean for an algorithm to be fault-tolerant? The answer depends on the type of failure, the number of failures, and many other dimensions.</p>

<p>This topic is beyond the scope of our survey. Still, given the nature of distributed environments in which failures are inevitable (e.g., restarting a server as part of continuous integration), we will briefly overview a few distributed training systems and their approaches to dealing with failures.</p>

<p>Note that it’s crucial to address failures when building a training service - given that the service time (i.e., training time) can be hours, days, or even weeks. In other words, IMHO, asking clients to re-train their model due to a faulty server is not the best design choice.</p>

<ul>
  <li>Project Adam (see <a class="citation" href="#DBLP:conf/osdi/ChilimbiSAK14">[24]</a>):
    <ul>
      <li>Impact of slow machines:
        <ul>
          <li>Single sample processing speed when using partitioned model approach depends on the slowest participant. To mitigate this problem, they allowed threads on each participant to process multiple samples in parallel.</li>
          <li>The slowest participant delays the end time of each epoch, as all training samples are required to compute model prediction error on the validation data set (which determines if another epoch is needed). They addressed this issue by ending epochs after a fraction of the samples (e.g., 75%) are completely processed and shuffling the samples order before each epoch to ensure coverage.</li>
        </ul>
      </li>
      <li>Each parameter shard (a 1MB block of parameters) has three copies stored on a different parameter server. A primary-backup scheme is used among those three servers (i.e., a primary that serves the parameters and two secondaries that maintain copies).</li>
      <li>Clients communicate with a fault-tolerant coordination service to find the parameter server that holds their required parameter shard. This coordination service is responsible for sharding the model and for the assignments of PS servers (generally, it uses Paxos). A lease mechanism is used for detecting faulty servers.</li>
    </ul>
  </li>
  <li>GeePS and Poseidon (see <a class="citation" href="#DBLP:conf/eurosys/CuiZGGX16">[29]</a>, and <a class="citation" href="#DBLP:conf/usenix/ZhangZXDHLHWXX17">[30]</a>):
    <ul>
      <li>In these systems, the parameter server continuously checkpoints the current states in persistent storage.</li>
    </ul>
  </li>
</ul>

<h2 id="from-ideas-to-practice">From Ideas to Practice</h2>

<p>This section gives an overview of the leading frameworks and libraries available today that supports distributed training.</p>

<p>In the following list, we mention for each framework its name, APIs, and supported algorithms:</p>

<ol>
  <li>Chainer (<a class="citation" href="#Chainer">[31]</a>) | APIs: Python | Supported Algorithms:
    <ul>
      <li>Decentralized only</li>
      <li>Synchronous only</li>
      <li>Model quantization not supported</li>
      <li>Gradient quantization not supported</li>
    </ul>
  </li>
  <li>DL4j (<a class="citation" href="#DL4J">[32]</a>) | APIs: Java | Supported Algorithms:
    <ul>
      <li>Centralized and decentralized</li>
      <li>Synchronous and asynchronous</li>
      <li>Model quantization not supported</li>
      <li>Modified 1-bit gradient quantization by Strom supported</li>
    </ul>
  </li>
  <li>Keras (<a class="citation" href="#Keras">[33]</a>) | APIs: DL4j, TensorFlow | Supported Algorithms:
    <ul>
      <li>Model quantization supported</li>
      <li>Higher-level concepts must be implemented in the DL framework that employs Keras</li>
    </ul>
  </li>
  <li>MXNet (<a class="citation" href="#MXNet">[34]</a> and <a class="citation" href="#MXNet-with-Horovod">[35]</a>) | APIs: C++, Go, Java-Script, Matlab, Python, Scala, Wolfram, Julia, Perl, R | Supported Algorithms:
    <ul>
      <li>Centralized and decentralized</li>
      <li>Synchronous and asynchronous</li>
      <li>Model quantization supported</li>
      <li>2-bit gradient quantization with error-feedback supported</li>
    </ul>
  </li>
  <li>PyTorch (See Section <a href="#pytorch">PyTorch</a>) | APIs: C++, Python | Supported Algorithms:
    <ul>
      <li>Centralized and decentralized</li>
      <li>Synchronous and asynchronous</li>
      <li>Model quantization is supported in beta</li>
      <li>Gradient quantization is supported in beta</li>
    </ul>
  </li>
  <li>SINGA (<a class="citation" href="#Signa">[36]</a>) | APIs: C++, Python | Supported Algorithms:
    <ul>
      <li>Centralized and decentralized</li>
      <li>Synchronous and asynchronous</li>
      <li>Model quantization not supported</li>
      <li>Gradient quantization not supported</li>
    </ul>
  </li>
  <li>TensorFlow (<a class="citation" href="#DBLP:conf/osdi/AbadiBCCDDDGIIK16">[37]</a>, and see Section <a href="#tensorflow--w-keras">TensorFlow</a>) | APIs: C++, Go, Java, Java-Script, Python, Swift | Supported Algorithms:
    <ul>
      <li>Centralized and decentralized</li>
      <li>Synchronous and asynchronous</li>
      <li>Model quantization supported (with Keras)</li>
      <li>Gradient quantization not supported (but on roadmap..)</li>
    </ul>
  </li>
</ol>

<p>We now focus on two frameworks - TensorFlow and PyTorch:</p>

<h3 id="tensorflow--w-keras">TensorFlow ( w/ Keras)</h3>

<p>TensorFlow natively supports distributed and parallel training (see <a class="citation" href="#Distributed-training-with-TensorFlow">[38, 39, 40, 41, 42, 43]</a>). In particular, it supports both model parallelism and data parallelism. In data parallelism, the centralized approach via parameter servers is supported, using either asynchronous or synchronous training. Trained models can be quantized using TensorFlow Lite (see <a class="citation" href="#Post-training-quantization">[44]</a>). Currently, there is no native support for gradient quantization <a class="citation" href="#Quantization-aware-training">[45]</a>, but this can be done via Keras <a class="citation" href="#Quantization-aware-training-in-Keras-example">[46]</a>.</p>

<h3 id="pytorch">PyTorch</h3>

<p>PyTorch has native support for distributed, data-parallel training, as well as model-parallel training (see <a class="citation" href="#PYTORCH-distributed">[47, 48]</a>). For data-parallel training, PyTorch implements the decentralized architecture and supports synchronous and asynchronous training. PyTorch supports model quantization via the QNNPACK library (see <a class="citation" href="#Quantized">[49]</a>). Gradient quantization is supported (see <a class="citation" href="#Pytorch-QUANTIZATION">[50]</a>).</p>

<h2 id="building-a-training-service---related-topics">Building a Training Service - Related Topics</h2>

<p>Topics that weren’t covered in this survey but are related to building &amp; maintaining a training service -</p>

<ol>
  <li>Scheduling and Elasticity (see Section 3.4 in <a class="citation" href="#DBLP:journals/csur/MayerJ20">[2]</a>)</li>
  <li>Data Management (see Section 3.5 in <a class="citation" href="#DBLP:journals/csur/MayerJ20">[2]</a>)</li>
</ol>

<h2 id="epilogue">Epilogue</h2>

<p>I hope you found this summary helpful and that you feel that you know the challenges in distributed training.</p>

<figure class="">
  <img src="/assets/images/DNN-Training-Images/I-Know-DT.png" alt=""></figure>

<p>I tried to keep it short and mention just the essential parts required for developing an intuition about the topic.
If you think something is missing, incorrect, or just can be improved, please feel free to reach out. I’ll appreciate any feedback. Thanks!</p>

<h2 id="refrences">Refrences</h2>

<ol class="bibliography">
<li><span id="DBLP:journals/csur/Ben-NunH19">Tal Ben-Nun and Torsten Hoefler. <b>Demystifying Parallel and Distributed Deep Learning: An In-depth Concurrency
               Analysis</b>. <i>ACM Comput. Surv.</i>, 52(4) :65:1–65:43, 2019.</span></li>
<li><span id="DBLP:journals/csur/MayerJ20">Ruben Mayer and Hans-Arno Jacobsen. <b>Scalable Deep Learning on Distributed Infrastructures: Challenges,
               Techniques, and Tools</b>. <i>ACM Comput. Surv.</i>, 53(1) :3:1–3:37, 2020.</span></li>
<li><span id="DBLP:conf/icml/MirhoseiniPLSLZ17">Azalia Mirhoseini, Hieu Pham, Quoc V. Le, Benoit Steiner, Rasmus Larsen, Yuefeng Zhou, Naveen Kumar, Mohammad Norouzi, Samy Bengio, and Jeff Dean. <b>Device Placement Optimization with Reinforcement Learning</b>. In: Precup, D. and Teh, Y.W. (eds.) <i>Proceedings of the 34th International Conference on Machine Learning,
               ICML 2017, Sydney, NSW, Australia, 6-11 August 2017</i>, pp. 2430–2439, PMLR, 2017.</span></li>
<li><span id="DBLP:conf/cloud/LuoNCPK18">Liang Luo, Jacob Nelson, Luis Ceze, Amar Phanishayee, and Arvind Krishnamurthy. <b>Parameter Hub: a Rack-Scale Parameter Server for Distributed Deep
               Neural Network Training</b>. In: <i>Proceedings of the ACM Symposium on Cloud Computing, SoCC 2018,
               Carlsbad, CA, USA, October 11-13, 2018</i>, pp. 41–54, ACM, 2018.</span></li>
<li><span id="DBLP:conf/nips/HoCCLKGGGX13">Qirong Ho, James Cipar, Henggang Cui, Seunghak Lee, Jin Kyu Kim, Phillip B. Gibbons, Garth A. Gibson, Gregory R. Ganger, and Eric P. Xing. <b>More Effective Distributed ML via a Stale Synchronous Parallel Parameter
               Server</b>. In: Burges, C.J.C., Bottou, L., Ghahramani, Z., and Weinberger, K.Q. (eds.) <i>Advances in Neural Information Processing Systems 26: 27th Annual
               Conference on Neural Information Processing Systems 2013. Proceedings
               of a meeting held December 5-8, 2013, Lake Tahoe, Nevada, United States</i>, pp. 1223–1231 2013.</span></li>
<li><span id="DBLP:journals/corr/abs-1902-06855">Peng Sun, Wansen Feng, Ruobing Han, Shengen Yan, and Yonggang Wen. <b>Optimizing Network Performance for Distributed DNN Training on GPU
               Clusters: ImageNet/AlexNet Training in 1.5 Minutes</b>. <i>CoRR</i>, abs/1902.06855 2019.</span></li>
<li><span id="DBLP:journals/jpdc/PatarasukY09">Pitch Patarasuk and Xin Yuan. <b>Bandwidth optimal all-reduce algorithms for clusters of workstations</b>. <i>J. Parallel Distributed Comput.</i>, 69(2) :117–124, 2009.</span></li>
<li><span id="DBLP:journals/corr/abs-1807-11205">Xianyan Jia, Shutao Song, Wei He, Yangzihao Wang, Haidong Rong, Feihu Zhou, Liqiang Xie, Zhenyu Guo, Yuanzhou Yang, Liwei Yu, Tiegang Chen, Guangxiao Hu, Shaohuai Shi, and Xiaowen Chu. <b>Highly Scalable Deep Learning Training System with Mixed-Precision:
               Training ImageNet in Four Minutes</b>. <i>CoRR</i>, abs/1807.11205 2018.</span></li>
<li><span id="DBLP:conf/apsys/WangZGZ14">Minjie Wang, Hucheng Zhou, Minyi Guo, and Zheng Zhang. <b>A scalable and topology configurable protocol for distributed parameter
               synchronization</b>. In: <i>Asia-Pacific Workshop on Systems, APSys’14, Beijing, China, June 25-26,
               2014</i>, pp. 13:1–13:7, ACM, 2014.</span></li>
<li><span id="DBLP:conf/cloud/WatcharapichatM16">Pijika Watcharapichat, Victoria Lopez Morales, Raul Castro Fernandez, and Peter R. Pietzuch. <b>Ako: Decentralised Deep Learning with Partial Gradient Exchange</b>. In: Aguilera, M.K., Cooper, B., and Diao, Y. (eds.) <i>Proceedings of the Seventh ACM Symposium on Cloud Computing, Santa
               Clara, CA, USA, October 5-7, 2016</i>, pp. 84–97, ACM, 2016.</span></li>
<li><span id="DBLP:conf/nips/LianZZHZL17">Xiangru Lian, Ce Zhang, Huan Zhang, Cho-Jui Hsieh, Wei Zhang, and Ji Liu. <b>Can Decentralized Algorithms Outperform Centralized Algorithms? A
               Case Study for Decentralized Parallel Stochastic Gradient Descent</b>. In: Guyon, I., Luxburg, U. von, Bengio, S., Wallach, H.M., Fergus, R., Vishwanathan, S.V.N., and Garnett, R. (eds.) <i>Advances in Neural Information Processing Systems 30: Annual Conference
               on Neural Information Processing Systems 2017, December 4-9, 2017,
               Long Beach, CA, USA</i>, pp. 5330–5340 2017.</span></li>
<li><span id="DBLP:journals/jpdc/OuyangDXX21">Shuo Ouyang, Dezun Dong, Yemao Xu, and Liquan Xiao. <b>Communication optimization strategies for distributed deep neural
               network training: A survey</b>. <i>J. Parallel Distributed Comput.</i>, 149 :52–65, 2021.</span></li>
<li><span id="10754/662495">Hang Xu, Chen-Yu Ho, Ahmed M. Abdelmoniem, Aritra Dutta, El Houcine Bergou, Konstantinos Karatsenidis, Marco Canini, and Panos Kalnis. <b>Compressed Communication for Distributed Deep Learning: Survey and Quantitative Evaluation</b>. 2020.</span></li>
<li><span id="DBLP:journals/corr/GoyalDGNWKTJH17">Priya Goyal, Piotr Dollár, Ross B. Girshick, Pieter Noordhuis, Lukasz Wesolowski, Aapo Kyrola, Andrew Tulloch, Yangqing Jia, and Kaiming He. <b>Accurate, Large Minibatch SGD: Training ImageNet in 1 Hour</b>. <i>CoRR</i>, abs/1706.02677 2017.</span></li>
<li><span id="DBLP:conf/iclr/KeskarMNST17">Nitish Shirish Keskar, Dheevatsa Mudigere, Jorge Nocedal, Mikhail Smelyanskiy, and Ping Tak Peter Tang. <b>On Large-Batch Training for Deep Learning: Generalization Gap and
               Sharp Minima</b>. In: <i>5th International Conference on Learning Representations, ICLR 2017,
               Toulon, France, April 24-26, 2017, Conference Track Proceedings</i>, OpenReview.net, 2017.</span></li>
<li><span id="DBLP:conf/mlsys/HashemiJC19">Sayed Hadi Hashemi, Sangeetha Abdu Jyothi, and Roy H. Campbell. <b>TicTac: Accelerating Distributed Deep Learning with Communication
               Scheduling</b>. In: Talwalkar, A., Smith, V., and Zaharia, M. (eds.) <i>Proceedings of Machine Learning and Systems 2019, MLSys 2019, Stanford,
               CA, USA, March 31 - April 2, 2019</i>, mlsys.org, 2019.</span></li>
<li><span id="DBLP:conf/cloud/WeiDQHCGGGX15">Jinliang Wei, Wei Dai, Aurick Qiao, Qirong Ho, Henggang Cui, Gregory R. Ganger, Phillip B. Gibbons, Garth A. Gibson, and Eric P. Xing. <b>Managed communication and consistency for fast data-parallel iterative
               analytics</b>. In: Ghandeharizadeh, S., Barahmand, S., Balazinska, M., and Freedman, M.J. (eds.) <i>Proceedings of the Sixth ACM Symposium on Cloud Computing, SoCC
               2015, Kohala Coast, Hawaii, USA, August 27-29, 2015</i>, pp. 381–394, ACM, 2015.</span></li>
<li><span id="DBLP:journals/taco/XuDZXL20">Yemao Xu, Dezun Dong, Yawei Zhao, Weixia Xu, and Xiangke Liao. <b>OD-SGD: One-Step Delay Stochastic Gradient Descent for Distributed
               Training</b>. <i>ACM Trans. Archit. Code Optim.</i>, 17(4) :30:1–30:26, 2020.</span></li>
<li><span id="grpc-and-zeromq-comparison"><b>grpc and zeromq comparsion</b>, https://stackoverflow.com/questions/39350681/grpc-and-zeromq-comparsion, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="DBLP:conf/isca/LeeKCDKNSSCHSD10">Victor W. Lee, Changkyu Kim, Jatin Chhugani, Michael Deisher, Daehyun Kim, Anthony D. Nguyen, Nadathur Satish, Mikhail Smelyanskiy, Srinivas Chennupaty, Per Hammarlund, Ronak Singhal, and Pradeep Dubey. <b>Debunking the 100X GPU vs. CPU myth: an evaluation of throughput
               computing on CPU and GPU</b>. In: Seznec, A., Weiser, U.C., and Ronen, R. (eds.) <i>37th International Symposium on Computer Architecture (ISCA 2010),
               June 19-23, 2010, Saint-Malo, France</i>, pp. 451–460, ACM, 2010.</span></li>
<li><span id="DBLP:conf/hpca/HazelwoodBBCDDF18">Kim M. Hazelwood, Sarah Bird, David M. Brooks, Soumith Chintala, Utku Diril, Dmytro Dzhulgakov, Mohamed Fawzy, Bill Jia, Yangqing Jia, Aditya Kalro, James Law, Kevin Lee, Jason Lu, Pieter Noordhuis, Misha Smelyanskiy, Liang Xiong, and Xiaodong Wang. <b>Applied Machine Learning at Facebook: A Datacenter Infrastructure
               Perspective</b>. In: <i>IEEE International Symposium on High Performance Computer Architecture,
               HPCA 2018, Vienna, Austria, February 24-28, 2018</i>, pp. 620–629, IEEE Computer Society, 2018.</span></li>
<li><span id="DBLP:journals/pvldb/ZouJLGWX14">Yongqiang Zou, Xing Jin, Yi Li, Zhimao Guo, Eryu Wang, and Bin Xiao. <b>Mariana: Tencent Deep Learning Platform and its Applications</b>. <i>Proc. VLDB Endow.</i>, 7(13) :1772–1777, 2014.</span></li>
<li><span id="DBLP:conf/nips/DeanCMCDLMRSTYN12">Jeffrey Dean, Greg Corrado, Rajat Monga, Kai Chen, Matthieu Devin, Quoc V. Le, Mark Z. Mao, Marc’Aurelio Ranzato, Andrew W. Senior, Paul A. Tucker, Ke Yang, and Andrew Y. Ng. <b>Large Scale Distributed Deep Networks</b>. In: Bartlett, P.L., Pereira, F.C.N., Burges, C.J.C., Bottou, L., and Weinberger, K.Q. (eds.) <i>Advances in Neural Information Processing Systems 25: 26th Annual
               Conference on Neural Information Processing Systems 2012. Proceedings
               of a meeting held December 3-6, 2012, Lake Tahoe, Nevada, United States</i>, pp. 1232–1240 2012.</span></li>
<li><span id="DBLP:conf/osdi/ChilimbiSAK14">Trishul M. Chilimbi, Yutaka Suzue, Johnson Apacible, and Karthik Kalyanaraman. <b>Project Adam: Building an Efficient and Scalable Deep Learning Training
               System</b>. In: Flinn, J. and Levy, H. (eds.) <i>11th USENIX Symposium on Operating Systems Design and Implementation,
               OSDI ’14, Broomfield, CO, USA, October 6-8, 2014</i>, pp. 571–582, USENIX Association, 2014.</span></li>
<li><span id="DBLP:journals/tpds/LiSCLLTB20">Ang Li, Shuaiwen Leon Song, Jieyang Chen, Jiajia Li, Xu Liu, Nathan R. Tallent, and Kevin J. Barker. <b>Evaluating Modern GPU Interconnect: PCIe, NVLink, NV-SLI, NVSwitch
               and GPUDirect</b>. <i>IEEE Trans. Parallel Distributed Syst.</i>, 31(1) :94–110, 2020.</span></li>
<li><span id="DBLP:conf/nsdi/SapioC0NKKKMPR21">Amedeo Sapio, Marco Canini, Chen-Yu Ho, Jacob Nelson, Panos Kalnis, Changhoon Kim, Arvind Krishnamurthy, Masoud Moshref, Dan R. K. Ports, and Peter Richtárik. <b>Scaling Distributed Machine Learning with In-Network Aggregation</b>. In: Mickens, J. and Teixeira, R. (eds.) <i>18th USENIX Symposium on Networked Systems Design and Implementation,
               NSDI 2021, April 12-14, 2021</i>, pp. 785–808, USENIX Association, 2021.</span></li>
<li><span id="DBLP:conf/micro/AlwaniCFM16">Manoj Alwani, Han Chen, Michael Ferdman, and Peter A. Milder. <b>Fused-layer CNN accelerators</b>. In: <i>49th Annual IEEE/ACM International Symposium on Microarchitecture,
               MICRO 2016, Taipei, Taiwan, October 15-19, 2016</i>, pp. 22:1–22:12, IEEE Computer Society, 2016.</span></li>
<li><span id="DBLP:conf/fccm/ShenFM17">Yongming Shen, Michael Ferdman, and Peter A. Milder. <b>Escher: A CNN Accelerator with Flexible Buffering to Minimize
               Off-Chip Transfer</b>. In: <i>25th IEEE Annual International Symposium on Field-Programmable Custom
               Computing Machines, FCCM 2017, Napa, CA, USA, April 30 - May 2,
               2017</i>, pp. 93–100, IEEE Computer Society, 2017.</span></li>
<li><span id="DBLP:conf/eurosys/CuiZGGX16">Henggang Cui, Hao Zhang, Gregory R. Ganger, Phillip B. Gibbons, and Eric P. Xing. <b>GeePS: scalable deep learning on distributed GPUs with a GPU-specialized
               parameter server</b>. In: Cadar, C., Pietzuch, P.R., Keeton, K., and Rodrigues, R. (eds.) <i>Proceedings of the Eleventh European Conference on Computer Systems,
               EuroSys 2016, London, United Kingdom, April 18-21, 2016</i>, pp. 4:1–4:16, ACM, 2016.</span></li>
<li><span id="DBLP:conf/usenix/ZhangZXDHLHWXX17">Hao Zhang, Zeyu Zheng, Shizhen Xu, Wei Dai, Qirong Ho, Xiaodan Liang, Zhiting Hu, Jinliang Wei, Pengtao Xie, and Eric P. Xing. <b>Poseidon: An Efficient Communication Architecture for Distributed
               Deep Learning on GPU Clusters</b>. In: Silva, D.D. and Ford, B. (eds.) <i>2017 USENIX Annual Technical Conference, USENIX ATC 2017, Santa
               Clara, CA, USA, July 12-14, 2017</i>, pp. 181–193, USENIX Association, 2017.</span></li>
<li><span id="Chainer"><b>Chainer</b>, https://docs.chainer.org/en/stable/chainermn/index.html, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="DL4J"><b>DL4J’s Distributed Training Implementations</b>, https://deeplearning4j.konduit.ai/spark/tutorials/dl4j-on-spark-quickstart#dl4js-distributed-training-implementations, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="Keras"><b>Keras - Multi-GPU and distributed training</b>, https://keras.io/guides/distributed_training/, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="MXNet"><b>MXNet</b>, https://mxnet.apache.org/versions/1.8.0/, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="MXNet-with-Horovod"><b>Distributed Training using Apache MXNet with Horovod</b>, https://medium.com/apache-mxnet/distributed-training-using-apache-mxnet-with-horovod-44f98bf0e7b7, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="Signa"><b>Signa - Distributed Training</b>, https://singa.apache.org/docs/dist-train/, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="DBLP:conf/osdi/AbadiBCCDDDGIIK16">Abadi Martı́n, Paul Barham, Jianmin Chen, Zhifeng Chen, Andy Davis, Jeffrey Dean, Matthieu Devin, Sanjay Ghemawat, Geoffrey Irving, Michael Isard, Manjunath Kudlur, Josh Levenberg, Rajat Monga, Sherry Moore, Derek Gordon Murray, Benoit Steiner, Paul A. Tucker, Vijay Vasudevan, Pete Warden, Martin Wicke, Yuan Yu, and Xiaoqiang Zheng. <b>TensorFlow: A System for Large-Scale Machine Learning</b>. In: Keeton, K. and Roscoe, T. (eds.) <i>12th USENIX Symposium on Operating Systems Design and Implementation,
               OSDI 2016, Savannah, GA, USA, November 2-4, 2016</i>, pp. 265–283, USENIX Association, 2016.</span></li>
<li><span id="Distributed-training-with-TensorFlow"><b>Distributed training with TensorFlow</b>, https://www.tensorflow.org/guide/distributed_training, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="TensorFlow-Optimize-further"><b>TensorFlow - Optimize further</b>, https://www.tensorflow.org/model_optimization/guide/optimize_further, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="Distributed-TensorFlow-training"><b>Distributed TensorFlow training (Google I/O ’18)</b>, https://www.youtube.com/watch?v=bRMGoPqsn20, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="Inside-TensorFlow-tf.data-tf.distribute"><b>Inside TensorFlow: tf.data + tf.distribute (Dev Summit 2019)</b>, https://www.youtube.com/watch?v=ZnukSLKEw34, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="Inside-TensorFlow-tf.distribute.Strategy"><b>Inside TensorFlow: tf.distribute.Strategy</b>, https://www.youtube.com/watch?v=jKV53r9-H14, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="Scaling-TensorFlow-2-models-to-multi-worker-GPUs"><b>Scaling TensorFlow 2 models to multi-worker GPUs (TF Dev Summit ‘20)</b>, https://www.youtube.com/watch?v=6ovfZW8pepo, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="Post-training-quantization"><b>Post-training quantization</b>, https://www.tensorflow.org/lite/performance/post_training_quantization, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="Quantization-aware-training"><b>Quantization aware training</b>, https://www.tensorflow.org/model_optimization/guide/quantization/training, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="Quantization-aware-training-in-Keras-example"><b>Quantization aware training in Keras example</b>, https://www.tensorflow.org/model_optimization/guide/quantization/training_example, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="PYTORCH-distributed"><b>PYTORCH DISTRIBUTED OVERVIEW</b>, https://pytorch.org/tutorials/beginner/dist_overview.html, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="TORCH.DISTRIBUTED"><b>DISTRIBUTED COMMUNICATION PACKAGE - TORCH.DISTRIBUTED</b>, https://pytorch.org/docs/stable/distributed.html?highlight=distributed#basics, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="Quantized"><b>Quantized Neural Networks PACKage</b>, https://github.com/pytorch/QNNPACK, 2021 Accesssed: 2021-12-20.</span></li>
<li><span id="Pytorch-QUANTIZATION"><b>Pytorch QUANTIZATION</b>, https://pytorch.org/docs/stable/quantization.html, 2021 Accesssed: 2021-12-20.</span></li>
</ol>

        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2022-01-11T00:00:00-08:00">January 11, 2022</time></p>

      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=Distributed+Deep+Neural+Network+%28DNN%29+Training+for+Practitioners%20https%3A%2F%2Fkfirlevari.github.io%2FDNN-Training%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fkfirlevari.github.io%2FDNN-Training%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A%2F%2Fkfirlevari.github.io%2FDNN-Training%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/CreatingAWebSite/" class="pagination--pager" title="DIY - Homepage with Jekyll &amp; Minimal Mistakes in GitHub.
">Previous</a>
    
    
      <a href="#" class="pagination--pager disabled">Next</a>
    
  </nav>

    </div>

    
      <div class="page__comments">
  
  
      <h4 class="page__comments-title">Leave a comment</h4>
      <section id="giscus-comments"></section>
    
</div>

    
  </article>

  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="http://il.linkedin.com/in/kfirlevari/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> Linkedin</a></li>
        
      
        
          <li><a href="https://scholar.google.co.il/citations?hl=en&amp;user=SdzwxKEAAAAJ&amp;view_op=list_works&amp;sortby=pubdate" rel="nofollow noopener noreferrer"><i class="ai ai-google-scholar" aria-hidden="true"></i> Google Scholar</a></li>
        
      
        
          <li><a href="http://dblp2.uni-trier.de/pers/hd/l/Lev=Ari:Kfir" rel="nofollow noopener noreferrer"><i class="ai ai-dblp" aria-hidden="true"></i> DBLP</a></li>
        
      
        
          <li><a href="https://github.com/kfirlevari" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.patreon.com/user/creators?u=65820883" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-patreon" aria-hidden="true"></i> Patreon</a></li>
        
      
        
          <li><a href="https://bandcamp.com/kfirlev-ari" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-bandcamp" aria-hidden="true"></i> Bandcamp</a></li>
        
      
        
          <li><a href="https://www.strava.com/athletes/42969031" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-strava" aria-hidden="true"></i> Strava</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">© 2022 Kfir Lev-Ari. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>







  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-CYB6SXB214"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CYB6SXB214', { 'anonymize_ip': false});
</script>






    <script>
  'use strict';

  (function () {
    var commentContainer = document.querySelector('#giscus-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    script.setAttribute('data-repo', 'kfirlevari/kfirlevari.github.io');
    script.setAttribute('data-repo-id', 'MDEwOlJlcG9zaXRvcnk2Mzk1MzM2MA==');
    script.setAttribute('data-category', 'Announcements');
    script.setAttribute('data-category-id', 'DIC_kwDOA8_Z0M4CAQqJ');
    script.setAttribute('data-mapping', 'pathname');
    script.setAttribute('data-reactions-enabled', '1');
    script.setAttribute('data-theme', 'light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>
  





  </body>
</html>
